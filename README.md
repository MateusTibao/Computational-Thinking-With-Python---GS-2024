<h1 align="center">
    <img alt="NextLevelWeek" title="#NextLevelWeek" src="./assets/mare cheia.svg" />
</h1>

<h3 align="center"> 
	 MarÃ© Cheia  
</h3>

<p align="center">
  <a href="## ğŸ£ Problema abordado">ğŸ£ Problema â€¢</a>
  <a href="## ğŸ¦¾ SoluÃ§Ã£o proposta">ğŸ¦¾ SoluÃ§Ã£o â€¢</a>
  <a href="## âœ… Features ">âœ… Features â€¢</a>
  <a href="### ğŸš§Componentes Principais">ğŸš§Componentes Principais â€¢ </a>
 <a href="### âš™ï¸Funcionalidades Principais">âš™ï¸ Funcionalidades Principais â€¢  </a> 
 <a href="## âš™ï¸ CÃ³digo fonte">âš™ï¸ CÃ³digo-fonte â€¢</a> 
 <a href=" ## ğŸ‘¨ğŸ½â€ğŸ­ğŸ‘¨ğŸ½â€ğŸ”§ğŸ‘¨ğŸ½â€ğŸ­ Autores">ğŸ‘¨ğŸ½â€ğŸ­ğŸ‘¨ğŸ½â€ğŸ”§ğŸ‘¨ğŸ½â€ğŸ­ Autores â€¢</a>
 <a href="## ğŸ“ LicenÃ§a">ğŸ“ LicenÃ§a â€¢</a>
</p>


## ğŸ£ Problema abordado

A sobrepesca representa uma ameaÃ§a crÃ­tica aos ecossistemas marinhos, superando outras formas de degradaÃ§Ã£o ambiental. A captura excessiva de peixes alÃ©m do ritmo de reproduÃ§Ã£o natural causa um desequilÃ­brio nos ecossistemas oceÃ¢nicos e leva Ã  diminuiÃ§Ã£o drÃ¡stica das populaÃ§Ãµes de diversas espÃ©cies. Este fenÃ´meno afeta a biodiversidade marinha e tem implicaÃ§Ãµes diretas para as comunidades que dependem dos recursos pesqueiros para sua subsistÃªncia. Implementar tecnologias inovadoras, como sensores para monitoramento em tempo real, Ã© essencial para mitigar os efeitos da sobrepesca e garantir a sustentabilidade dos recursos pesqueiros para futuras geraÃ§Ãµes.


## ğŸ¦¾ SoluÃ§Ã£o proposta

Para abordar o problema da sobrepesca e a saÃºde dos ecossistemas marinhos locais, propomos o desenvolvimento de um sistema integrado que utiliza sensores ESP 32 para coleta de dados em tempo real, seguido por anÃ¡lise desses dados e apresentaÃ§Ã£o em um dashboard interativo. Este sistema visa fornecer insights valiosos para comunidades costeiras, empresas e governantes, auxiliando na tomada de decisÃµes informadas para a promoÃ§Ã£o da sustentabilidade dos recursos pesqueiros e a recuperaÃ§Ã£o dos ecossistemas marinhos.

## âœ… Features 
- [X] Site disponibilizando informaÃ§Ãµes para usuÃ¡rio
- [X] ProtÃ³tipo de sensores
- [X] AnÃ¡lise de dados
---


### ğŸš§Componentes Principais

- **Sensores ESP 32**: Dispositivos embarcados utilizados para coleta de dados ambientais, incluindo pH, turbidez, temperatura e presenÃ§a de peixes.
- **AnÃ¡lise de Dados**: Processamento e anÃ¡lise dos dados coletados para identificar tendÃªncias, padrÃµes e indicadores de saÃºde do ecossistema marinho.
- **Dashboard Interativo**: Interface web baseada em React que exibe os dados analisados de forma visual e acessÃ­vel, permitindo a fÃ¡cil interpretaÃ§Ã£o por diferentes pÃºblicos interessados.

### âš™ï¸Funcionalidades Principais

#### Coleta de Dados
Os sensores ESP 32 sÃ£o implantados estrategicamente nas Ã¡reas de interesse para coletar dados ambientais em tempo real. Os dados coletados incluem medidas de pH, turbidez, temperatura e detecÃ§Ã£o de peixes.

#### AnÃ¡lise de Dados
Os dados coletados sÃ£o processados e analisados utilizando Python, com bibliotecas como `matplotlib` para visualizaÃ§Ã£o de dados e `math` para cÃ¡lculos estatÃ­sticos. A anÃ¡lise permite calcular mÃ©tricas importantes como mÃ©dias, desvios padrÃ£o, mÃ­nimos, mÃ¡ximos e variÃ¢ncias para cada atributo medido.

#### Dashboard Interativo
Um dashboard interativo foi desenvolvido utilizando React, permitindo a visualizaÃ§Ã£o dos resultados da anÃ¡lise de dados de forma clara e intuitiva. O dashboard suporta mÃºltiplas visualizaÃ§Ãµes, incluindo grÃ¡ficos de linhas e colunas, facilitando a compreensÃ£o dos padrÃµes observados nos dados.

### ImplementaÃ§Ã£o

A implementaÃ§Ã£o do sistema envolve vÃ¡rias etapas, desde a configuraÃ§Ã£o e programaÃ§Ã£o dos sensores ESP 32 atÃ© o desenvolvimento do backend de anÃ¡lise de dados e a criaÃ§Ã£o do frontend do dashboard. Cada componente do sistema foi projetado para ser modular e escalÃ¡vel, permitindo facilidade de manutenÃ§Ã£o e atualizaÃ§Ãµes futuras.

### ConclusÃ£o

Este projeto representa um passo significativo na direÃ§Ã£o de uma gestÃ£o sustentÃ¡vel dos recursos pesqueiros e na proteÃ§Ã£o dos ecossistemas marinhos. Ao fornecer dados precisos e anÃ¡lises detalhadas, esperamos contribuir para a tomada de decisÃµes informadas e eficazes por parte das partes interessadas, promovendo a saÃºde e a sustentabilidade dos ecossistemas marinhos locais.

---

**Nota:** O cÃ³digo Python fornecido acima Ã© uma implementaÃ§Ã£o detalhada do backend de anÃ¡lise de dados, que Ã© uma parte crucial deste projeto. Ele cobre todas as funcionalidades necessÃ¡rias para processar e analisar os dados coletados pelos sensores ESP 32, bem como para gerar visualizaÃ§Ãµes grÃ¡ficas essenciais para entender a saÃºde dos ecossistemas marinhos.

## âš™ï¸ CÃ³digo fonte
import json
from datetime import datetime
import matplotlib.pyplot as plt
import math

# IMPORTAÃ‡ÃƒO DE BIBLIOTECAS â–²
# TRATAMENTO DE DADOS â–¼

def importar_dados(caminho_arquivo):
    # ImportaÃ§Ã£o de dados via arquivo .json
    try:
        with open(caminho_arquivo, 'r') as f:
            dados = json.load(f)
        return dados
    except FileNotFoundError:
        print(f"Erro: arquivo '{caminho_arquivo}' nÃ£o encontrado. ImpossÃ­vel continuar, verifique e reinicie.")
        exit()
    except json.JSONDecodeError:
        print(f"Erro ao decodificar o arquivo JSON '{caminho_arquivo}'. Verifique a formataÃ§Ã£o do arquivo.")
    return []

def selecionar_regiao(dados):
    # ExibiÃ§Ã£o das regiÃµes disponÃ­veis usando generator expression com set evitando duplicatas e geraÃ§Ã£o de lista antes do necessÃ¡rio
    regioes = list(set(item['regiao'] for item in dados))
    print("RegiÃµes disponÃ­veis:")
    for i, regiao in enumerate(regioes):
        print(f"{i + 1} - {regiao}")

    # Loop para seleÃ§Ã£o da regiÃ£o
    while True:
        try:
            opcao = int(input("\nDigite o nÃºmero da regiÃ£o desejada: "))
            if 1 <= opcao <= len(regioes):
                regiao_selecionada = regioes[opcao - 1]
                return regiao_selecionada, [item for item in dados if item['regiao'] == regiao_selecionada]
            else:
                print("OpÃ§Ã£o invÃ¡lida. Por favor, digite um nÃºmero vÃ¡lido.")
        except ValueError:
            print("Entrada invÃ¡lida. Por favor, digite um nÃºmero.")

def exibir_periodo_disponivel(dados):
    # Mesma lÃ³gica da exibiÃ§Ã£o das regiÃ£o mas aqui as datas sÃ£o ordenadas para ser possÃ­vel selecionar a mais antiga e a mais recente
    datas = sorted(set(item['data'] for item in dados))
    data_inicio = datas[0]
    data_fim = datas[-1]
    print(f"\nPerÃ­odo disponÃ­vel de {data_inicio} a {data_fim}")

def selecionar_periodo():
    # Loop de seleÃ§Ã£o do perÃ­odo fazendo as devidas validaÃ§Ãµes
    while True:
        data_inicio = input("\nDigite a data de inÃ­cio (AAAA-MM-DD): ").strip()
        data_fim = input("Digite a data de fim (AAAA-MM-DD): ").strip()
        if len(data_inicio) == 10 and len(data_fim) == 10:
            try:
                data_inicio_dt = datetime.strptime(data_inicio, '%Y-%m-%d')
                data_fim_dt = datetime.strptime(data_fim, '%Y-%m-%d')
                if data_inicio_dt <= data_fim_dt:
                    return {'data_inicio': data_inicio, 'data_fim': data_fim}
                else:
                    print("Erro: a data de inÃ­cio deve ser anterior ou igual Ã  data de fim.")
            except ValueError:
                print("Erro: formataÃ§Ã£o de data invÃ¡lida. Certifique-se de usar o formato AAAA-MM-DD.")
        else:
            print("Erro: formataÃ§Ã£o de data invÃ¡lida. Certifique-se de usar o formato AAAA-MM-DD.")

def filtrar_por_periodo(dados, data_inicio, data_fim):
    # Converte strings de data de inÃ­cio e fim para objetos datetime
    data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d')
    data_fim = datetime.strptime(data_fim, '%Y-%m-%d')

    # Retorna uma lista de itens cuja data estÃ¡ dentro do intervalo especificado com list comprehension
    return [item for item in dados if data_inicio <= datetime.strptime(item['data'], '%Y-%m-%d') <= data_fim]

# TRATAMENTO DE DADO â–²
# CÃLCULOS â–¼

def calcular_media(dados, atributo):
    # CÃ¡lculo da mÃ©dia e arrendamento do resultado
    valores = [item[atributo] for item in dados]
    return round(sum(valores) / len(valores), 2)

def calcular_desvio_padrao(dados, atributo):
    # CÃ¡lculo do desvio padrÃ£o e arrendamento do resultado
    valores = [item[atributo] for item in dados]
    media = calcular_media(dados, atributo)
    variancia = sum((x - media) ** 2 for x in valores) / len(valores)
    return round(math.sqrt(variancia), 2)

def calcular_minimo(dados, atributo):
    # Retorno do mÃ­nimo
    valores = [item[atributo] for item in dados]
    return min(valores) if valores else 0

def calcular_maximo(dados, atributo):
    # Retorno do mÃ­nimo
    valores = [item[atributo] for item in dados]
    return max(valores) if valores else 0

def calcular_variancia(dados, atributo):
    # CÃ¡lculo da variÃ¢ncia
    valores = [item[atributo] for item in dados]
    media = calcular_media(dados, atributo)
    return round(sum((x - media) ** 2 for x in valores) / len(valores), 2)

def imprimir_calculos(dados, tipo_calculo, atributos):
    # Itera sobre cada atributo e seu nome, realizando o cÃ¡lculo correspondente e imprimindo o resultado
    print(f"\n{tipo_calculo.capitalize()} para todos os atributos:\n")
    for atributo, nome in atributos.items():
        if tipo_calculo == 'media':
            valor = calcular_media(dados, atributo)
        elif tipo_calculo == 'desvio_padrao':
            valor = calcular_desvio_padrao(dados, atributo)
        elif tipo_calculo == 'minimo':
            valor = calcular_minimo(dados, atributo)
        elif tipo_calculo == 'maximo':
            valor = calcular_maximo(dados, atributo)
        elif tipo_calculo == 'variancia':
            valor = calcular_variancia(dados, atributo)
        print(f"{nome}: {valor}")

# CÃLCULOS â–²
# GRÃFICOS â–¼

def gerar_grafico_linha(dados, atributo):
    # GeraÃ§Ã£o do grÃ¡fico de linha usando matplotlib.pyplot
    datas = [item['data'] for item in dados]
    valores = [item[atributo] for item in dados]

    plt.figure(figsize=(10, 6))
    plt.plot(datas, valores, marker='o', linestyle='-', color='b')
    plt.xlabel('Data')
    plt.ylabel(atributo.capitalize())
    plt.title(f'GrÃ¡fico de {atributo.capitalize()} por data')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.grid(True)
    plt.show()

def gerar_grafico_colunas(dados, atributo):
    # GeraÃ§Ã£o do grÃ¡fico de colunas usando matplotlib.pyplot
    datas = [item['data'] for item in dados]
    valores = [item[atributo] for item in dados]

    plt.figure(figsize=(10, 6))
    plt.bar(datas, valores, color='b')
    plt.xlabel('Data')
    plt.ylabel(atributo.capitalize())
    plt.title(f'GrÃ¡fico de Colunas de {atributo.capitalize()} por Data')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.grid(True)
    plt.show()

def exibir_opcoes_grafico(atributos):
    # Sub-menu para seleÃ§Ã£o do tipo de grÃ¡fico
    print("\nVÃRIAVEL DO GRÃFICO:")
    for i, atributo in enumerate(atributos):
        print(f"{i + 1} - {atributos[atributo]}")
    while True:
        try:
            opcao = int(input("\nDigite o nÃºmero do atributo para gerar o grÃ¡fico: "))
            if 1 <= opcao <= len(atributos):
                return list(atributos.keys())[opcao - 1]
            else:
                print("OpÃ§Ã£o invÃ¡lida. Por favor, digite um nÃºmero vÃ¡lido.")
        except ValueError:
            print("Entrada invÃ¡lida. Por favor, digite um nÃºmero.")

# GRÃFICOS â–²
# GERAIS â–¼

def main():
    dados = importar_dados('dados.json')

    while True:
        # SeleÃ§Ã£o da regiÃ£o e do perÃ­odo antes do looping para enviar fluxo sem a seleÃ§Ã£o
        regiao_selecionada, dados_regiao = selecionar_regiao(dados)
        exibir_periodo_disponivel(dados)
        periodo_selecionado = selecionar_periodo()

        # Mapeiamento os nomes tÃ©cnicos dos atributos para descriÃ§Ãµes legÃ­veis para os usuÃ¡rios
        atributos = {
            'temp': 'Temperatura',
            'turbidez': 'Turbidez',
            'ph': 'pH',
            'presenca_de_peixes': 'PresenÃ§a de Peixes'
        }

        # Loop do menu principal com acesso e recrutamento das funÃ§Ãµes do cÃ³digo
        while True:

            # DefiniÃ§Ã£o as datas de inÃ­cio e fim do perÃ­odo selecionado pelo usuÃ¡rio
            data_inicio = periodo_selecionado['data_inicio']
            data_fim = periodo_selecionado['data_fim']

            # Filtro final dos dados da regiÃ£o selecionada para o perÃ­odo especificado
            dados_periodo = filtrar_por_periodo(dados_regiao, data_inicio, data_fim)

            print(f"\nPerÃ­odo: de {data_inicio} atÃ© {data_fim}\nRegiÃ£o: {regiao_selecionada}\n")
            print("1 - Calcular MÃ©dias")
            print("2 - Calcular Desvios PadrÃµes")
            print("3 - Calcular VariÃ¢ncias")
            print("4 - Calcular MÃ­nimas")
            print("5 - Calcular MÃ¡ximas")
            print("6 - Gerar GrÃ¡fico de Linhas EspecÃ­fico")
            print("7 - Gerar GrÃ¡fico de Colunas EspecÃ­fico")
            print("8 - Selecionar Novo PerÃ­odo")
            print("0 - Selecionar Nova RegiÃ£o")
            print("S - Sair")

            opcao = input("\nDigite o nÃºmero da opÃ§Ã£o desejada: ").strip().lower()

            if opcao == '1':
                imprimir_calculos(dados_periodo, 'media', atributos)
            elif opcao == '2':
                imprimir_calculos(dados_periodo, 'desvio_padrao', atributos)
            elif opcao == '3':
                imprimir_calculos(dados_periodo, 'variancia', atributos)
            elif opcao == '4':
                imprimir_calculos(dados_periodo, 'minimo', atributos)
            elif opcao == '5':
                imprimir_calculos(dados_periodo, 'maximo', atributos)
            elif opcao == '6':
                atributo = exibir_opcoes_grafico(atributos)
                gerar_grafico_linha(dados_periodo, atributo)
            elif opcao == '7':
                atributo = exibir_opcoes_grafico(atributos)
                gerar_grafico_colunas(dados_periodo, atributo)
            elif opcao == '8':
                periodo_selecionado = selecionar_periodo()
            elif opcao == '0':
                break
            elif opcao == 's':
                print("Encerrando o programa...")
                return
            else:
                print("OpÃ§Ã£o invÃ¡lida. Por favor, digite um nÃºmero vÃ¡lido ou 'S' para sair.")

main()


## ğŸ‘¨ğŸ½â€ğŸ­ğŸ‘¨ğŸ½â€ğŸ”§ğŸ‘¨ğŸ½â€ğŸ­ Autores
<p align="center">
<table>
  <tr>
    <td align="center">
      <a href="https://github.com/Gh0stE11">
        <img style="border-radius: 50%;" src="https://media.licdn.com/dms/image/C4E03AQGQNxYibVc4nA/profile-displayphoto-shrink_400_400/0/1655830181624?e=1723075200&v=beta&t=rWSJ14lOO0KYwGnE_JMGTHId1k7G9h1PRCWAk9HYbtQ" width="100px;" alt=""/>
        <br />
        <sub><b>Caio Hideki</b></sub> <sub><br><b>RM 553630</b></sub>
      </a>
      <br />
      ğŸš€
    </td>
    <td align="center">
      <a href="https://github.com/JorgeBooz00">
        <img style="border-radius: 50%;" src="https://avatars.githubusercontent.com/u/107008455?v=4" width="100px;" alt=""/>
        <br />
        <sub><b>Jorge Booz</b></sub> <sub><br><b>RM 552700</b></sub>
      </a>
      <br />
      ğŸš€
    </td>
    <td align="center">
      <a href="https://github.com/MateusTibao">
        <img style="border-radius: 50%;" src="https://avatars.githubusercontent.com/u/143664123?v=4" width="100px;" alt=""/>
        <br />
        <sub><b>Mateus Tibao</b></sub> <sub><br><b>RM 553267</b></sub>
      </a>
      <br />
      ğŸš€
    </td>
  </tr>
</table>
</p>


## ğŸ“ LicenÃ§a

Este projeto esta sobe a licenÃ§a [MIT](./LICENSE).

Feito com muita vontade de aprender por [Caio Hideki](https://www.linkedin.com/in/caio-hideki-cardenas-ishizu-24208a243/), [Jorge Booz](https://www.linkedin.com/in/jorge-booz-4038a2213/) e [Mateus TibÃ£o](https://www.linkedin.com/in/mateustibao/) ğŸ‘‹ğŸ»ğŸ‘‹ğŸ½ğŸ‘‹ğŸ½ 

---
